## 设计模式

首先如果你只是单纯的为了写一个页面的话，不介意那种强行追求设计模式。强扭的瓜不甜，设计模式使用的场景，是一些大型的项目，比如你要开发一个站点。

**什么是设计模式？**

设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。



我们来通过一个例子，了解理解一下上面这段*非人类的话* 。

在人类起源开始进步发展的过程中，有一个东西必不可少，那就是房子，一个私有的领域、空间，但是在最开始的时候，人类会建造房子吗？ 肯定是不会的。都是一代人不断的摸索出来的。

假设我们第一个建造成功的是一件草房，我们要干什么？ 是不是要先找到房子的支点，然后有个草制的屋顶。一间简陋的 草屋制成了，但是在使用中发现，这个屋子只能遮挡小雨，且风一吹就倒了，于是，房屋的支点不再随意摆放，开始嵌入地面，成为地基。

这些是什么，是不是建造房子的时候总结的经验。

那这些经验放到同领域其他地方还有用吗？

肯定是能用的。

比方说，我们现在不建草屋了，改成泥瓦房，同样的是不是需要用到地基，屋顶，围墙？

这就是前人总结的经验。 



但是要注意，每个领域都有其起源，巅峰。

我们称这个为 **黑匣子**

这是什么呢？ 

比如说，建房子，一开始我们就是建草屋对吧，然后有一个需求，突然让我们整个摩天大厦。 这能做吗？ 

再比如说，手机，我们日常使用现在已经是不可或缺的东西，但是在古代，是没有手机的，如果我们让 古人做一部手机，他肯定是做不出来的。很困难 。首先他要先了解电路，然后是通信的原理，然后学习如何制作屏幕 等等，需要攻克的技术难关太多了。但是我们现在就不同了。你想做手机对吧，行 ，我在三星订购一个屏幕，然后淘宝买主板、后盖，等一切资源。我们都能得到。 而我们需要做的是什么？ 是不是只需要拼装就可以了。

这就是设计模式的初衷，在日常开发，和项目应用中能够，更加高效的开发，更大可能的复用逻辑代码。

设计模式都是前人总结好的我们直接拿来用就行。

说白了，设计模式就相当于 套路，我们要想出一个套路来针对我们已知的需求问题。

为什么说设计模式像套路呢？

比如，一个三角形，我们知道两条边，如何确定第三条边呢？

我们学过数学肯定知道 **勾股定理** 这个公式对吧。但是这个公式是怎么来的？ 是不是通过不断的实验，不断的总结，才得出的这种结论，然后我们现在，只需要知道我们根据这个数学公式，能够推导出第三条边，这就是我们的目的，对前人经验的使用。以前可能要 1 天才能试出来，但是现在，我们只需要经过计算，很快就能得到。大大的加快了我们的效率。



**设计模式的目的是什么？**

为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。

设计模式使代码编写真正工程化

设计模式是软件荣成的基石脉络，如同大厦的结构一样。



**设计模式的原则是什么？**

*耐心读下去，希望你能对程序有一种新的认知，一种不一样的升华。*

首先，有一个小问题要问下自己，**你认为对人类约束力最大的是什么？**

多花点时间好好思考。

ok。

我这里有两种答案，第一：法律约束了我们自身，第二：我们的思想约束了自身。

如果你的想法是法律的话，那和答案的偏差还是有点距离的。为什么这么说呢？

法律应该是一种不得已的情况，就是觉得我没有办法觉得你做的事情是对的错的，因为你已经超过了人类的**底线**，有点难懂，我们举个例子。

假设我们是新手，开始直接敲代码。但是我们忽略了一个问题，新手对于代码的规则一窍不通，如果我们违反了这个语言规则，如 我们未声明变量，直接取用。最终的结果是什么？

是不是报错了呀？  但是为什么报错，因为我们 js 引擎不得已，没有办法解析出你写的这是什么。对不对？ 所以他动用法律来惩罚你，报错了，让你焦头烂额。

我们得出了一个结论。 **法律是底线（守护和平的红线）**。对应我们程序中来说就是 **bug红线。** 我们的程序不能报错对吧，因为报错说明代码已经执行不下去了，不可信的。



第二，我们的思想约束自身。不完全正确。为什么呢？

我们要明确，我们的思想是怎么来的？ “古人云：人之初，性本善”，我们相信每个新生命都是善良的，那为什么 还会有坏人呢？ 坏人又是怎么来的呢？

这取决于我们的思想，但是我们的思想同时又被其他的因素影响。 环境、人文属性。

儒家思想确立 **仁义礼智信** ，贯穿古今，我们至今也被这种属性约束自身。仁义礼智信 是我们的一种对 **伦理道德的理解**， 等同于我们做人的原则。是这种伦理道德的观念时时刻刻的影响着我们。



但是原则最大的影响的地方，是让你如何做好一个人，对吧？ 归根究底，**是在权衡利弊**。

假设，小王同学，想做个好人，那么他会怎么样？扶老奶奶过马路，捡到钱交给警察叔叔，坐公交车给老人让座。对吧 等等等等··· 这些都是能让你成为好人的途径。在这个过程中，由于你想成为好人，你在权衡之下，决定做出这些事情，虽然付出了一些代价，但是，你赢得了他人对你的看法，印象。 你想成为坏人同理是吧，你权衡之下觉得名声并不重要···。

再比如，菜市场，如果你的菜又好又便宜是不是都愿意去你家买，但是，如果你的菜都是那种快要变质的，还贵，还给人家缺斤短两。还会有人去吗？



其实，越到后面，就会发现，设计模式更像是一种另类的人文，只不过，是人和机器之间的交流。我们也在时时刻刻的**权衡空间与时间**的问题。



所以我们要干什么？ **在守住底线，坚持原则的基础上，考虑我们的问题。**

总结来说就是

没有套路做事情没效率，笨拙，重用性小，情况 复杂的时候，所需要攻克的问题太大，成本太高。有了套路，我们就能更容易的解决一些复杂的问题，让开发变得高效、简单。



普及一下知识。



设计模式最早出现是为了解决后端的需求问题，因为早期前端需求并没有这么复杂，他的初衷就是为了解决一些面向对象的问题，虽然 ES6 已经在往免现对象靠拢。



设计模式研究的就是 对象。

比如我们使用的话首先要创建一个对象，就可以用到创建型的工厂模式，有了对象之后我们是不是要描绘他的结构啊，这时候可以从结构型模式中找到适用的 - 代理模式，有了结构之后，还要描述他的行为，行为类型 - 观察者模式。 等等···



**谈一下设计模式的六大原则**

减少耦合，增强复用，降低代码的开发维护扩展成本。



**什么是耦合呢 ？**

耦合关系是指两个事物之间如果存在一种相互作用、相互影响的关系，那么这种关系叫做“耦合关系”。

举个例子：

假设有一个男生和一个女生，他们在一起了，这时候他们就叫情侣是吧，然后他们每天吃饭睡觉都在一起，相互影响，久而久之，男生越来越干净，女生说话越来越像男生。

对比于我们前端来说

假设有一个函数 A ，这个函数 A 需要做一些操作，但是发现功能不够用，又调用了函数 B。这种直接的关系。

再假设有一个 对象，这个对象呢 有一个行为影响了另外一个对象。 这样的直接的关系我们称之为耦合。

我们说，只要是两个对象也好、函数也好，他们之间有这种相互作用的联系。这就叫做耦合性。像是有一根绳子在牵着他们。

*但是这种情况不叫耦合*

假设我们有一个函数，这个函数呢有一个功能，会使全局中某个状态发生改变，然后巧合的是存在另外一个函数，这个函数的功能呢是监听这个全局状态，当这个状态发生改变时进行一系列的操作。

这是耦合吗？

虽然他确实是通过一些手段使得两个函数存在了关系，但是里面是不是有个第三者啊，就是这个全局的状态对吧。也就是说，他们两个之间的关系不够存粹。

这不是耦合！



**耦合度和复杂度的危害**

 什么是复杂度呢？

大家都知道书法对吧？ 什么宋体、隶书、楷书、草书。有的时候你就会发现有的书法，你能看明白，知道是什么字，但是有的字体，哇哦···· 称之为天数不为过吧，格式杂乱，字体飞舞。这个时候你看起来是不是特别费劲？

再比如，  ES6之前，有一个有意思的东西就是 “嵌套地狱”，你就发现一个函数里面，TM 全是 if ··· else ···。

假设你有一个可爱的同事，平时啥事没有，就一个乐趣，写 if else，然后有一天他离职了，然后呢老板把他的需求转给了你，然后你一看代码，人傻了。想改个代码，发现 找括号就找了半天，还不包括看逻辑。那最后怎么办呢？ 是不是只能重构了。

这种代码，就是那种复杂度很高，一个脚本就一个函数，剩下全是 if else。所有的逻辑都放在一个函数里面。 几千行啊··· 你瞅着那个括号眼睛疼不。



复杂度：

复杂度高，表示代码质量不高，可维护性差，复用性差，不易扩展。

耦合度：

耦合度无，是不可能的···，耦合度低，程度合理，过高则不容易维护。但是扩展性、复用性好。



**所以我们开发时的流程是什么？**

 本着优先降低复杂度的思想，尽量的去减少耦合度。但是有一点你要注意，你的复杂度和耦合度是息息相关的，你的复杂度降低，自然而然的你的耦合度就会上升。

+ 通过单一职责原则，开闭原则，里氏替换原则，来降低复杂度（但是会提升耦合度）
+ 通过迪米特法则来减少耦合度
+ 通过依赖倒置原则消除可以没有的耦合度

读到这里，我们就会发现，**权衡**贯穿了整个设计模式的全部。而降低复杂度，减少耦合度就是我们的原则。





**应用：**

**-- 使用设计模式六大原则 - 单一职责原则**

单一职责原则总体思想就是，各司其职，各做各的。不再同一函数中做其他的事情。避免功能混淆，导致无法复用、扩展。

这种就是典型的通过增加耦合度来降低复杂度的例子，下面我们通过伪代码来模拟一下。







**创建型 - 研究高效的创建对象**

+ 单例模式
+ 抽象工厂模式
+ 建造者模式
+ 工厂模式
+ 原型模式



**结构型模式 - 设计对象的结构和关系**

+ 适配器模式
+ 桥接模式
+ 装饰模式
+ 组合模式
+ 外观模式
+ 亨元模式
+ 代理模式



**行为型模式 - 设计对象的行为**

+ 模板方法模式
+ 命令模式
+ 迭代器模式
+ 观察者模式
+ 中介者模式
+ 备忘录模式
+ 解释器模式
+ 状态模式
+ 策略模式
+ 职责链模式
+ 访问者模式




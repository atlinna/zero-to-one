# 编译过程

## webpack 的作用就是将源代码编译成最终代码

## webpack 的的编译过程大概分为三部分

    - 初始化
    - 编译
    - 输出

### 初始化阶段

    此阶段会通过webpack-cli 提供的webpack命令 将cli参数，配置文件、默认配置进行融合形成一个最终的配置对象。
    对配置的融合依赖于一个第三方依赖 yargs
    主要是为了给编译环境产生一个最终的配置。

### 编译

    1、创建chunk：chunk是webpack在内部构建过程中的一个概念，“块”，他表示通过某个入口找到的所有依赖的总称。
    根据入口模块（默认为 ./src/index.js）创建一个chunk
    chunk 有两个属性：
    name：默认为main
    id：唯一编号，开发环境和name相同，生产环境是一个数字，从0开始
    2、构建所有依赖模块
    3、产生chunk assets 资源列表
    在第二部完成后，chunk中会产生一个模块列表，列表中包含了模块id和模块转换后的代码。--类似编译结果。
    转换后的代码
    然后 webpack 会根据配置为chunk生成一个资源列表，即chunk assets，资源列表可以理解为是 生成到最终文件的文件名和文件内容。
    chunk hash 通过 hash工具取到 每个chunk的hash值
    4、将每个chunk的hash值汇总 形成一个总的hash值和一个总的资源列表。

### 输出

    通过node 内置模块 fs 将文件输出

## node

‘./’表示的意义
1、模块化代码中表示的是当前 js 文件的所在陌路
2、在路径处理中， 表示 node 运行目录

\_\_dirname:所有情况下都表示当前运行的 js 文件所在的目录

## 入口和出口

出口 通过 output 进行配置 配置的是资源列表
入口 配置的 是 chunk

output 是一个对象 有两个属性

- path : 配置的是生成资源的文件夹目录，必须是绝对路径，表示资源防止的位置
- filename ：配置的是合并后的 js 文件的规则
  - filename 动态写法：
  - [name] --> 表示可以动态的根据 chunk 的名称来创建生成资源的名
  - [hash] --> 当浏览器请求页面时 如果发现引用的文件名一致则会采用缓存 这个时候如果更新了内部资源 浏览器用的还是之前的缓存。
    生成的 hash 值就是我们的最后资源列表的总 hash， 使用 hash 值目的就是反馈我们的文件有没有发生变化
  - [hash:5] --> 使用前 5 位 hash 值
  - [chunkhash] --> 如果只有单个 chunk 发生了变化 则只有这个 chunk 的文件名改变

entry 也是个对象

```
entry:{
    main:'./src/main.js' //属性名是 chunk 的名称，属性值是入口文件
    a:'./src/a.js' //通过 entry 创建了多个 chunk 然后 如果 output filename 是配置的静态的 则会冲突， 因为每个 chunk 都会生成一个 bundle，
共有两个 bundle 但是只有一个 bundle.js 的出口 -- 冲突了
}
```

--》 entry:"./src/main.js"
entry 还能配置多个入口文件 比如：

```
entry:{
    a:['./src/main.js','./src/a.js']
}
```

这样还是只生成一个 bundle，因为只有一个块 chunk， 只是他的依赖列表变大了 它会按照这个数组的顺序 先执行第一个 在执行第二个

## 入口和出口的应用。

### 一个页面一个 js

如果有多个页面 则证明有多个入口，那么每个入口都能创建一个 chunk ，
问题：如果生成的代码中都有重复代码会造成什么问题，是否会影响版本维护
不会！
原因：最终生成的代码是经过 webpack 打包编译之后的 我们的公共代码早已抽离出功能模块 对我们的代码来说只存在一个。
造成的影响就是增加了传输量。

### 一个页面多个 js

### 单页应用


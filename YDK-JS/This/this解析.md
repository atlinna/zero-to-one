# this全面解析

理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。
**分析出真正的调用位置很重要，因为它决定了 this 的绑定。**

## 绑定规则
### 默认绑定
首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。
示例：
```
    function test() {
        console.log(this.a);
    }

    var a = 10;
    test() // 10；
```
首先我们是在全局作用域中声明的变量 a ，那么这个变量 a 本质上也是全局对象的一个属性，他们是相同的一个东西。
然后调用了 test 函数发现，this.a 被解析成了全局变量 a。这是什么原因呢？ 因为在调用函数的时候应用了 this 的**默认绑定**，因此 this 指向全局对象。
foo 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用**默认绑定**，无法应用其他规则。
**如果使用严格模式（ strict mode ），那么全局对象将无法使用默认绑定，因为 this 会绑定到 undefined ：**
虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()的调用位置无关

### 隐式绑定
另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。
示例：
```
    function test() {
        console.log(this.a);
    }

    var obj = {
        a: 10,
        test: test
    }
    var a = 20;
    obj.test() // 10
```
还是上一个 test 函数，这次我们在全局中声明了一个变量 a 和一个对象 obj。对象中也有一个同名属性 a。 和一个函数 test，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。当 foo() 被调用时，它的落脚点确实指向 obj 对象。
**当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。**

